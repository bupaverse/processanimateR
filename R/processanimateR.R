#' @title Animate cases on a process map
#'
#' @description A function for creating a SVG animation of an event log on a process map created by processmapR.
#' @param eventlog The event log object that should be animated
#' @param processmap The process map created with processmapR that the event log should be animated on,
#'  if not provided a standard process map will be generated by using processmapR::process_map.
#' @param animation_mode Whether to animate the cases according to their actual time of occurence ("absolute") or to start all cases at once ("relative").
#' @param animation_duration The overall duration of the animation, all times are scaled according to this overall duration.
#' @param animation_jitter The magnitude of a random coordinate translation, known as jitter in scatterplots, which is added to each token. Adding jitter can help to disambiguate tokens traveling on top of each other.
#' @param animation_timeline Whether to render a timeline slider in supported browsers (Recent versions of Chrome and Firefox only).
#' @param token_size The event attribute (character) or alternatively a data frame with three columns (case, time, size) matching the case identifier of the supplied event log.
#'  The token size is scaled accordingly during the animation (default size is 4). You may use \code{\link{add_token_size}} to add a suitable attribute to the event log.
#' @param token_color The event attribute (character) or alternatively a data frame with three columns (case, time, color) matching the case identifier of the supplied event log.
#'  The token color is change accordingly during the animation (default color is orange). You may use \code{\link{add_token_color}} to add a suitable attribute to the event log.
#' @param token_image The event attribute (character) or alternatively a data frame with three columns (case, time, image) matching the case identifier of the supplied event log.
#'  The token image is change accordingly during the animation (by default a SVG shape is used).
#' @param token_opacity The event attribute (character) or alternatively a data frame with three columns (case, time, transparency) matching the case identifier of the supplied event log.
#'  The token fill-opacity is change accordingly during the animation (by default the token is dranw with 0.9 opacity).
#' @param token_shape The (fixed) SVG shape to be used to draw tokens. Can be either 'circle' (default), 'rect' or 'image'. In the latter case the image URL needs to be specified as parameter 'token_image'.
#' @param token_options A list of additional (fixed) SVG properties to be added to each token.
#' @param token_callback_onclick A javascript function that is called when a token is clicked. The function is parsed by \code{\link{JS}} and received three parameters: 'svg_root', 'svg_element', and 'case_id'.
#' @param width,height Fixed size for widget (in css units). The default is NULL, which results in intelligent automatic sizing based on the widget's container.
#' @param ... Options passed on to \code{\link{process_map}}.
#'
#' @examples
#' # Load example event log
#' library(eventdataR)
#'
#' # Animate the process with default options (absolute time and 60s duration)
#' animate_process(patients)
#'
#' # Animate the process with default options (relative time and with jitter)
#' animate_process(patients, animation_mode = "relative", animation_jitter = 10)
#'
#' \donttest{
#' # Change default token sizes
#' animate_process(patients, token_size = 2)
#'
#' # Change default token color
#' animate_process(patients, token_color = "red")
#'
#' # Change default token opacity
#' animate_process(patients, token_opacity = 0.5)
#'
#' # Change default token image (GIFs work too)
#' animate_process(patients, token_image = "https://upload.wikimedia.org/wikipedia/en/5/5f/Pacman.gif")
#'
#' # Change token color based on a numeric attribute, here the nonsensical 'time' of an event
#' animate_process(add_token_color(patients, "time", "color"), token_color = "color")
#'
#' # Change token color based on a factor attribute
#' animate_process(add_token_color(patients, "employee", "color",
#'                 color_mapping = scales::col_factor("Set3", patients$employee)),
#'                 token_color = "color")
#'
#' # Next example requires the 'dplyr' and 'edeaR' packages
#' library(dplyr)
#' library(edeaR)
#'
#' # Change token_color based on colors in a second data frame
#' # Extract only the lacticacid measurements
#' lactic <- sepsis %>%
#'     mutate(lacticacid = as.numeric(lacticacid)) %>%
#'     filter_activity(c("LacticAcid")) %>%
#'     as.data.frame() %>%
#'     select("case" = case_id, "time" =  timestamp, lacticacid)
#' # Create a numeric color scale
#' cscale <- scales::col_numeric("Oranges", lactic$lacticacid , na.color = "white")
#' # Create colors data frame for animate_process
#' lacticColors <- lactic %>%
#'     mutate(color = cscale(lacticacid))
#' sepsisBase <- sepsis %>%
#'     filter_activity(c("LacticAcid", "CRP", "Leucocytes", "Return ER",
#'                       "IV Liquid", "IV Antibiotics"), reverse = TRUE) %>%
#'     filter_trace_frequency(percentage = 0.95)
#' animate_process(sepsisBase, token_color = lacticColors, animation_mode = "relative",
#'                 animation_duration = 600)
#' }
#'
#'
#' @author Felix Mannhardt <felix.mannhardt@sintef.no> (SINTEF Digital)
#' @seealso processmapR:process_map
#'
#' @import dplyr
#' @import bupaR
#' @import processmapR
#' @importFrom magrittr %>%
#' @importFrom rlang :=
#' @importFrom rlang !!
#'
#' @export
animate_process <- function(eventlog,
                            processmap = process_map(eventlog, render = F, ...),
                            animation_mode = "absolute",
                            animation_duration = 60,
                            animation_jitter = 0,
                            animation_timeline = TRUE,
                            token_size = NULL,
                            token_color = NULL,
                            token_image = NULL,
                            token_opacity = NULL,
                            token_shape = c("circle","rect","image"),
                            token_options = NULL,
                            token_callback_onclick = c("function(svg_root, svg_element, case_id) {",
                                                        "if (svg_element.attr('stroke') === 'red') {",
                                                        " svg_element.attr('stroke', 'black');",
                                                        "} else {",
                                                        " svg_element.attr('stroke', 'red');",
                                                        "}}"),
                            width = NULL,
                            height = NULL,
                            ...) {

  # Make CRAN happy about dplyr evaluation
  case_start <- log_end <- start_time <- end_time <- next_end_time <- next_start_time <- NULL
  case <- case_end <- log_start <- log_duration <- case_duration <- NULL
  from_id <- to_id <- NULL
  label <- NULL

  token_shape <- match.arg(token_shape)

  # Generate the DOT source
  graph <- DiagrammeR::render_graph(processmap, width = width, height = height)
  # Get the DOT source for later rendering through vis.js
  diagram <- DiagrammeRsvg::export_svg(graph)

  precedence <- attr(processmap, "base_precedence") %>%
    mutate_at(vars(start_time, end_time, next_start_time, next_end_time), as.numeric, units = "secs")

  cases <- precedence %>%
    group_by(case) %>%
    filter(!is.na(case)) %>%
    summarise(case_start = min(start_time, na.rm = T),
              case_end = max(end_time, na.rm = T)) %>%
    mutate(case_duration = case_end - case_start) %>%
    ungroup()

  # determine animation factor based on requested duration
  if (animation_mode == "absolute") {
    timeline_start <- cases %>% pull(case_start) %>% min(na.rm = T)
    timeline_end <- cases %>% pull(case_end) %>% max()
    animation_factor <- (timeline_end - timeline_start) / animation_duration
  } else {
    timeline_start <- 0
    timeline_end <- cases %>% pull(case_duration) %>% max(na.rm = T)
    animation_factor =  timeline_end / animation_duration
  }

  sizes <- generate_animation_attribute(eventlog, "size", token_size, 6)
  sizes <- transform_time(sizes, "size", cases, animation_mode, animation_factor, timeline_start, timeline_end)

  colors <- generate_animation_attribute(eventlog, "color", token_color, "white")
  colors <- transform_time(colors, "color", cases, animation_mode, animation_factor, timeline_start, timeline_end)

  images <- generate_animation_attribute(eventlog, "image", token_image, NA)
  images <- transform_time(images, "image", cases, animation_mode, animation_factor, timeline_start, timeline_end)

  if (token_shape == "image") {
    stopifnot(nrow(images) > 0, "Need to supply image URLs in parameter 'token_images' to use shape 'image'.");
  }

  opacities <- generate_animation_attribute(eventlog, "opacity", token_opacity, 0.9)
  opacities <- transform_time(opacities, "opacity", cases, animation_mode, animation_factor, timeline_start, timeline_end)

  tokens <- generate_tokens(cases, precedence, processmap, animation_mode, animation_factor, timeline_start, timeline_end)
  start_activity <- processmap$nodes_df %>% filter(label == "Start") %>% pull(id)
  end_activity <- processmap$nodes_df %>% filter(label == "End") %>% pull(id)

  settings <- list()
  x <- list(
    diagram = diagram,
    tokens = tokens,
    sizes = sizes,
    colors = colors,
    opacities = opacities,
    options = token_options,
    images = images,
    shape = token_shape,
    start_activity = start_activity,
    end_activity = end_activity,
    duration = animation_duration,
    timeline = animation_timeline,
    mode = animation_mode,
    jitter = animation_jitter,
    factor = animation_factor * 1000,
    timeline_start = timeline_start * 1000,
    timeline_end = timeline_end * 1000,
    onclick_callback = htmlwidgets::JS(token_callback_onclick)
  )

  htmlwidgets::createWidget(name = "processanimateR", x = x,
                            width = width, height = height,
                            sizingPolicy = htmlwidgets::sizingPolicy(
                              defaultWidth = 800,
                              defaultHeight = 600,
                              browser.fill = TRUE
                            ))
}

#' @title Create a process animation output element
#' @description Renders a renderProcessanimater within an application page.
#' @param outputId Output variable to read the animation from
#' @param width,height Must be a valid CSS unit (like 100%, 400px, auto) or a number,
#'  which will be coerced to a string and have px appended.
#'
#' @export
processanimaterOutput <- function(outputId, width = "100%", height = "400px") {
  htmlwidgets::shinyWidgetOutput(outputId = outputId,
                                 name = "processanimateR",
                                 inline = F,
                                 width = width, height = height,
                                 package = "processanimateR")
}

#' @title Renders process animation output
#' @description Renders a SVG process animation suitable to be used by processanimaterOutput.
#' @param expr The expression generating a process animation (animate_process).
#' @param env The environment in which to evaluate expr.
#' @param quoted Is expr a quoted expression (with quote())? This is useful if you want to save an expression in a variable.
#'
#' @export
renderProcessanimater <- function(expr, env = parent.frame(), quoted = FALSE) {
  if (!quoted) { expr <- substitute(expr) } # force quoted
  htmlwidgets::shinyRenderWidget(expr, processanimaterOutput, env, quoted = TRUE)
}

#
# Private helper functions
#

generate_tokens <- function(cases, precedence, processmap, animation_mode, animation_factor, timeline_start, timeline_end) {

  case <- end_time <- start_time <- next_end_time <- next_start_time <- case_start <- token_duration <- NULL
  min_order <- token_start <- activity_duration <- token_end <- from_id <- to_id <- case_duration <- NULL

  tokens <- precedence %>%
    left_join(cases, by = c("case")) %>%
    left_join(processmap$edges_df, by = c("from_id" = "from", "to_id" = "to")) %>%
    filter(!is.na(id) & !is.na(case))

  # SVG animations seem to not like events starting at the same time caused by 0s durations
  EPSILON = 0.00001

  if (animation_mode == "absolute") {
    tokens <- mutate(tokens,
                     token_start = (end_time - timeline_start) / animation_factor,
                     token_duration = (next_start_time - end_time) / animation_factor,
                     activity_duration = pmax(0, (next_end_time - next_start_time) / animation_factor))
  } else {
    tokens <- mutate(tokens,
                     token_start = (end_time - case_start) / animation_factor,
                     token_duration = (next_start_time - end_time) / animation_factor,
                     activity_duration = pmax(0, (next_end_time - next_start_time) / animation_factor))
  }

  tokens <- tokens %>%
    # Filter all negative durations caused by parallelism (TODO, deal with it in a better way)
    # Also, SMIL does not like 0 duration animateMotion
    filter(token_duration >= 0, activity_duration >= 0) %>%
    mutate(token_duration = EPSILON + token_duration,
           activity_duration = EPSILON + activity_duration) %>%
    arrange(case, start_time, min_order) %>%
    group_by(case) %>%
    # Ensure start times are not overlapping SMIL does not fancy this
    mutate(token_start = token_start + ((row_number(token_start) - min_rank(token_start)) * EPSILON)) %>%
    # Ensure consecutive start times
    mutate(token_end = min(token_start) + cumsum(token_duration + activity_duration) + EPSILON) %>%
    mutate(token_start = lag(token_end, default = min(token_start))) %>%
    # Adjust case duration
    mutate(case_duration = max(token_end)) %>%
    ungroup()

  tokens %>%
    select(case,
           edge_id = id,
           from_id,
           to_id,
           token_start,
           token_duration,
           activity_duration,
           case_duration)

}

generate_animation_attribute <- function(eventlog, attributeName, value, default) {
  attribute <- rlang::sym(attributeName)
  # standard token size
  if (is.null(value)) {
    eventlog %>%
      as.data.frame() %>%
      select(case = !!case_id_(eventlog),
             time = !!timestamp_(eventlog)) %>%
      mutate(!!attribute := default)
  } else if (is.data.frame(value)) {
    stopifnot(c("case", "time", attributeName) %in% colnames(value))
    value
  } else if (value %in% colnames(eventlog)) {
    eventlog %>%
      as.data.frame() %>%
      select(case = !!case_id_(eventlog),
             time = !!timestamp_(eventlog),
             !!rlang::sym(value)) %>%
      mutate(!!attribute := !!rlang::sym(value))
  } else {
    eventlog %>%
      as.data.frame() %>%
      select(case = !!case_id_(eventlog),
             time = !!timestamp_(eventlog)) %>%
      mutate(!!attribute := value)
  }
}

transform_time <- function(data, col, cases, animation_mode, animation_factor, timeline_start, timeline_end) {

  .order <- time <- case <- log_start <- case_start <- NULL

  col <- rlang::sym(col)
  data <- data %>%
    group_by(case) %>%
    filter(row_number(!!col) == 1 | lag(!!col) != !!col) %>%
    left_join(cases, by = "case")

  if (animation_mode == "absolute") {
    data <- data %>%
      mutate(time = as.numeric(time - timeline_start, units = "secs") / animation_factor) %>%
      select(case, time, !!col)
  } else {
    col <- data %>%
      mutate(time = as.numeric(time - case_start, units = "secs") / animation_factor) %>%
      select(case, time, !!col)
  }

}

# Utility functions
# https://github.com/gertjanssenswillen/processmapR/blob/master/R/utils.R
case_id_ <- function(eventlog) rlang::sym(case_id(eventlog))
timestamp_ <- function(eventlog) rlang::sym(timestamp(eventlog))
